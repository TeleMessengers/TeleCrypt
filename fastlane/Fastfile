require 'fileutils'
require 'tmpdir'
require 'base64'
require 'shellwords'

default_platform(:ios)

def ensure_upload_enabled!
  UI.user_error!("UPLOAD_TO_STORES is false") unless ENV["UPLOAD_TO_STORES"] == "true"
end

def env_value(*keys)
  keys.each do |key|
    value = ENV[key]
    return value unless value.nil? || value.empty?
  end
  nil
end

platform :ios do
  desc "Build TeleCrypt IPA for App Store/TestFlight distribution"
  lane :build do
    key_id = env_value("APP_STORE_CONNECT_KEY_ID", "KEY_ID")
    issuer_id = env_value("APP_STORE_CONNECT_ISSUER_ID", "ISSUER_ID")
    api_key_content = env_value("APP_STORE_CONNECT_API_KEY")
    UI.user_error!("APP_STORE_CONNECT_KEY_ID is missing") if key_id.to_s.empty?
    UI.user_error!("APP_STORE_CONNECT_ISSUER_ID is missing") if issuer_id.to_s.empty?
    UI.user_error!("APP_STORE_CONNECT_API_KEY is missing") if api_key_content.to_s.empty?
    keychain_password = ENV.fetch("APPLE_KEYCHAIN_PASSWORD").to_s.strip
    # allow using a separate password for the .p12 if provided
    certificate_password = env_value("APPLE_CERTIFICATE_PASSWORD") || keychain_password
    mobileprovision_base64 = ENV.fetch("IOS_MOBILEPROVISION_BASE64")

    unless api_key_content.include?("BEGIN PRIVATE KEY")
      begin
        decoded_key = Base64.decode64(api_key_content)
        api_key_content = decoded_key if decoded_key.include?("BEGIN PRIVATE KEY")
      rescue ArgumentError
        UI.user_error!("APP_STORE_CONNECT_API_KEY is not a valid raw key or base64 payload")
      end
    end

    api_key = app_store_connect_api_key(
      key_id: key_id,
      issuer_id: issuer_id,
      key_content: api_key_content,
      in_house: false
    )

    keychain_name = "telecrypt-ci-#{Time.now.to_i}"
    certificate_path = File.join(Dir.tmpdir, "telecrypt_ios.p12")
    provisioning_path = File.join(Dir.tmpdir, "telecrypt.mobileprovision")

    clean_cert = ENV.fetch("APPLE_KEYCHAIN_FILE_BASE64").to_s.gsub(/\s+/, "")
    clean_profile = mobileprovision_base64.to_s.gsub(/\s+/, "")
    File.binwrite(certificate_path, Base64.decode64(clean_cert))
    File.binwrite(provisioning_path, Base64.decode64(clean_profile))

    # lightweight diagnostics to compare with local artefacts (no secrets printed)
    begin
      p12_sha = sh("shasum -a 256 #{Shellwords.escape(certificate_path)} | awk '{print $1}'", log: false).strip
      prof_sha = sh("shasum -a 256 #{Shellwords.escape(provisioning_path)} | awk '{print $1}'", log: false).strip
      UI.message("Codesign diag: p12_sha256=#{p12_sha} profile_sha256=#{prof_sha}")
      # validate that password matches the p12 by extracting cert metadata (no keys printed)
      cert_info = sh("openssl pkcs12 -in #{Shellwords.escape(certificate_path)} -clcerts -nokeys -passin pass:'#{certificate_password}' | openssl x509 -noout -subject -issuer -enddate", log: false).to_s.strip
      UI.message("Codesign diag: certificate_info=#{cert_info}")
    rescue StandardError => e
      UI.important("Codesign diag: OpenSSL check failed — #{e.message}")
    end

    begin
      delete_keychain(name: keychain_name)
    rescue StandardError
      # ignore
    end
    create_keychain(
      name: keychain_name,
      password: keychain_password,
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: true
    )

    import_certificate(
      certificate_path: certificate_path,
      certificate_password: certificate_password,
      keychain_name: keychain_name,
      keychain_password: keychain_password
    )
    # list identities visible to the temporary keychain for easier troubleshooting
    begin
      identities = sh("security find-identity -p codesigning -v #{Shellwords.escape(keychain_name)}", log: false)
      UI.message("Codesign diag: identities in keychain '#{keychain_name}':\n#{identities}")
    rescue StandardError => e
      UI.important("Codesign diag: failed to list identities — #{e.message}")
    end
    install_provisioning_profile(path: provisioning_path)
    profile = FastlaneCore::ProvisioningProfile.parse(provisioning_path)
    profile_name = profile["Name"]
    bundle_identifier = profile["Entitlements"]["application-identifier"].split('.', 2).last
    UI.message("Using provisioning profile '#{profile_name}' for #{bundle_identifier}")

    ipa_path = build_app(
      project: "iosApp/iosApp.xcodeproj",
      scheme: "Tammy for iOS",
      export_method: "app-store",
      output_directory: "iosApp/build",
      output_name: "TeleCrypt",
      archive_path: "iosApp/build/TeleCrypt.xcarchive",
      clean: true,
      silent: true,
      build_path: "iosApp/build",
      derived_data_path: "iosApp/build/DerivedData",
      configuration: "Release",
      codesigning_identity: "Apple Distribution",
      export_team_id: ENV["APPLE_TEAM_ID"],
      xcargs: [
        "CODE_SIGN_STYLE=Manual",
        "CODE_SIGN_IDENTITY='Apple Distribution'",
        "PROVISIONING_PROFILE_SPECIFIER=#{Shellwords.escape(profile_name)}"
      ].join(" "),
      export_options: {
        provisioningProfiles: {
          bundle_identifier => profile_name
        },
        signingStyle: "manual",
        signingCertificate: "Apple Distribution"
      }
    )

    ipa_path
  ensure
    if defined?(certificate_path) && certificate_path
      FileUtils.rm_f(certificate_path)
    end
    if defined?(provisioning_path) && provisioning_path
      FileUtils.rm_f(provisioning_path)
    end
    if defined?(keychain_name) && keychain_name
      delete_keychain(name: keychain_name)
    end
  end

  desc "Upload TeleCrypt build to TestFlight (guarded by UPLOAD_TO_STORES flag)"
  lane :beta do
    ensure_upload_enabled!

    key_id = env_value("APP_STORE_CONNECT_KEY_ID", "KEY_ID")
    issuer_id = env_value("APP_STORE_CONNECT_ISSUER_ID", "ISSUER_ID")
    api_key_content = env_value("APP_STORE_CONNECT_API_KEY")

    api_key = app_store_connect_api_key(
      key_id: key_id,
      issuer_id: issuer_id,
      key_content: api_key_content
    )

    ipa_path = lane_context[SharedValues::IPA_OUTPUT_PATH] || Dir["iosApp/build/*.ipa"].max
    UI.user_error!("IPA not found — run fastlane ios build first") unless ipa_path

    upload_to_testflight(
      api_key: api_key,
      ipa: ipa_path,
      distribute_external: false,
      skip_submission: true
    )
  end
end

platform :android do
  desc "Upload TeleCrypt release to Google Play internal testing (guarded)"
  lane :internal do
    ensure_upload_enabled!

    service_json = env_value("ANDROID_SERVICE_ACCOUNT_JSON_BASE64")
    UI.user_error!("ANDROID_SERVICE_ACCOUNT_JSON_BASE64 is missing") if service_json.to_s.empty?

    service_account_path = File.join(Dir.tmpdir, "telecrypt_service_account.json")
    File.binwrite(service_account_path, Base64.decode64(service_json.gsub(/\s+/, "")))

    gradle(task: "bundleRelease")
    gradle(task: "assembleRelease")

    aab_candidates = Actions.lane_context[SharedValues::GRADLE_ALL_AAB_OUTPUT_PATHS] || []
    aab_path = aab_candidates.compact.select { |path| File.exist?(path) }.max
    UI.user_error!("Release AAB not found") unless aab_path

    supply(
      json_key: service_account_path,
      package_name: "com.zendev.telecrypt",
      track: "internal",
      aab: aab_path,
      skip_upload_apk: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      skip_upload_changelogs: true,
      skip_upload_metadata: true
    )
  ensure
    FileUtils.rm_f(service_account_path) if defined?(service_account_path)
  end
end
